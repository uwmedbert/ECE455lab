<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classtf_1_1Runtime" kind="class" language="C++" prot="public">
    <compoundname>tf::Runtime</compoundname>
    <includes refid="runtime_8hpp" local="no">taskflow/core/runtime.hpp</includes>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtf_1_1Runtime_1a763b2f90bc53f92d680a635fe28e858e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class Executor</definition>
        <argsstring></argsstring>
        <name>Executor</name>
        <param>
          <type><ref refid="classtf_1_1Executor" kindref="compound">Executor</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="51" column="3" bodyfile="taskflow/core/runtime.hpp" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1Runtime_1a61184f9bd9c801d0a5eccecfdbddc641" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class FlowBuilder</definition>
        <argsstring></argsstring>
        <name>FlowBuilder</name>
        <param>
          <type><ref refid="classtf_1_1FlowBuilder" kindref="compound">FlowBuilder</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="52" column="3" bodyfile="taskflow/core/runtime.hpp" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1Runtime_1adb56fdbfd3879bf32dbc9b766e797b55" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class PreemptionGuard</definition>
        <argsstring></argsstring>
        <name>PreemptionGuard</name>
        <param>
          <type>PreemptionGuard</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="53" column="3" bodyfile="taskflow/core/runtime.hpp" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1Runtime_1ab016b9124e80f55ad92e01579c060f08" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class Algorithm</definition>
        <argsstring></argsstring>
        <name>Algorithm</name>
        <param>
          <type>Algorithm</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="54" column="3" bodyfile="taskflow/core/runtime.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classtf_1_1Runtime_1a8074028372bb09946927b1b6ec01c6e1" prot="private" static="no" mutable="no">
        <type><ref refid="classtf_1_1Executor" kindref="compound">Executor</ref> &amp;</type>
        <definition>Executor&amp; tf::Runtime::_executor</definition>
        <argsstring></argsstring>
        <name>_executor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="630" column="12" bodyfile="taskflow/core/runtime.hpp" bodystart="630" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Runtime_1ae9bd2bcb1e004b078f627472fb9e0371" prot="private" static="no" mutable="no">
        <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        <definition>Worker&amp; tf::Runtime::_worker</definition>
        <argsstring></argsstring>
        <name>_worker</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="635" column="10" bodyfile="taskflow/core/runtime.hpp" bodystart="635" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Runtime_1ac040d7410fbb82703ac39ac3b1baf8fd" prot="private" static="no" mutable="no">
        <type>Node *</type>
        <definition>Node* tf::Runtime::_parent</definition>
        <argsstring></argsstring>
        <name>_parent</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="640" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="640" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1Executor" kindref="compound">Executor</ref> &amp;</type>
        <definition>Executor &amp; tf::Runtime::executor</definition>
        <argsstring>()</argsstring>
        <name>executor</name>
        <briefdescription>
<para>obtains the running executor </para>
        </briefdescription>
        <detaileddescription>
<para>The running executor of a runtime task is the executor that runs the parent taskflow of that runtime task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(&amp;(rt.<ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>())<sp/>==<sp/>&amp;<ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="73" column="12" bodyfile="taskflow/core/runtime.hpp" bodystart="651" bodyend="653"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1ae1dbce75fd7375ae3bf38948638e34ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        <definition>Worker &amp; tf::Runtime::worker</definition>
        <argsstring>()</argsstring>
        <name>worker</name>
        <briefdescription>
<para>acquire a reference to the underlying worker </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="78" column="17" bodyfile="taskflow/core/runtime.hpp" bodystart="656" bodyend="658"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1aa7e72cc0f298475195b252c8f1793343" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Runtime::schedule</definition>
        <argsstring>(Task task)</argsstring>
        <name>schedule</name>
        <param>
          <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>schedules an active task immediately to the worker&apos;s queue </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>the given active task to schedule immediately</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This member function immediately schedules an active task to the task queue of the associated worker in the runtime task. An active task is a task in a running taskflow. The task may or may not be running, and scheduling that task will immediately put the task into the task queue of the worker that is running the runtime task. Consider the following example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A,<sp/>B,<sp/>C,<sp/>D;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/utility/tuple/tie" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::tie</ref>(A,<sp/>B,<sp/>C,<sp/>D)<sp/>=<sp/>taskflow.emplace(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[&amp;C]<sp/>(<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt)<sp/>{<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>must<sp/>be<sp/>captured<sp/>by<sp/>reference</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.schedule(C);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D\n&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C,<sp/>D);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>The executor will first run the condition task <computeroutput>A</computeroutput> which returns <computeroutput>0</computeroutput> to inform the scheduler to go to the runtime task <computeroutput>B</computeroutput>. During the execution of <computeroutput>B</computeroutput>, it directly schedules task <computeroutput>C</computeroutput> without going through the normal taskflow graph scheduling process. At this moment, task <computeroutput>C</computeroutput> is active because its parent taskflow is running. When the taskflow finishes, we will see both <computeroutput>B</computeroutput> and <computeroutput>C</computeroutput> in the output.</para>
<para><simplesect kind="attention"><para>This method can only be called by the parent worker of this runtime, or the behavior is undefined. Furthermore, we currently do not support scheduling a runtime task. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="120" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="661" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::async</definition>
        <argsstring>(F &amp;&amp;f)</argsstring>
        <name>async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>runs the given callable asynchronously </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method creates an asynchronous task that executes the given function with the specified arguments. Unlike <ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">tf::Executor::async</ref>, the task created here is bound to the runtime object and is implicitly synchronized at the end of the runtime&apos;s scope. Applications may also call <ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">tf::Runtime::corun</ref> explicitly to wait for all asynchronous tasks spawned from the runtime to complete. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;int&gt;</ref><sp/>counter(0);</highlight></codeline>
<codeline><highlight class="normal">taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fu1<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" kindref="member">async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fu2<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" kindref="member">async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fu1.get();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fu2.get();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(counter<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>spawn<sp/>100<sp/>asynchronous<sp/>tasks<sp/>from<sp/>the<sp/>worker<sp/>of<sp/>the<sp/>runtime</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;100;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>explicitly<sp/>wait<sp/>for<sp/>the<sp/>100<sp/>asynchronous<sp/>tasks<sp/>to<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">corun</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(counter<sp/>==<sp/>102);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else<sp/>afterwards<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="159" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="720" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a333a76d63e50f3ddfbea60c4356b86f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;f)</argsstring>
        <name>async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>runs the given callable asynchronously </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Similar to <ref refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" kindref="member">tf::Runtime::async</ref>, but takes a parameter of type <ref refid="classtf_1_1TaskParams" kindref="compound">tf::TaskParams</ref> to initialize the created asynchronous task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>future<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" kindref="member">async</ref>(</highlight><highlight class="stringliteral">&quot;my<sp/>task&quot;</highlight><highlight class="normal">,<sp/>[](){});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>future.get();</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="182" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="726" bodyend="731"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Runtime::silent_async</definition>
        <argsstring>(F &amp;&amp;f)</argsstring>
        <name>silent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously without returning any future object </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is more efficient than <ref refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" kindref="member">tf::Runtime::async</ref> and is recommended when the result of the asynchronous task does not need to be accessed via a <ref refid="cpp/thread/future" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::future</ref>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;int&gt;</ref><sp/>counter(0);</highlight></codeline>
<codeline><highlight class="normal">taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;100;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">corun</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(counter<sp/>==<sp/>100);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="211" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="701" bodyend="703"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a532d8cd09ebee59023e3ad65f3220f4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Runtime::silent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;f)</argsstring>
        <name>silent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously without returning any future object </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Similar to <ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">tf::Runtime::silent_async</ref>, but takes a parameter of type <ref refid="classtf_1_1TaskParams" kindref="compound">tf::TaskParams</ref> to initialize the created asynchronous task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>(</highlight><highlight class="stringliteral">&quot;my<sp/>task&quot;</highlight><highlight class="normal">,<sp/>[](){});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="230" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="707" bodyend="712"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Runtime::silent_dependent_async</definition>
        <argsstring>(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A,<sp/>B);</highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="266" column="17" bodyfile="taskflow/core/runtime.hpp" bodystart="741" bodyend="745"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1abc1a77a8896529a8dea6f86997ea10e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Runtime::silent_dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="304" column="17" bodyfile="taskflow/core/runtime.hpp" bodystart="751" bodyend="758"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a3e5e2347c6ec2f29be72aaaf4c75391e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Runtime::silent_dependent_async</definition>
        <argsstring>(F &amp;&amp;func, I first, I last)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">Taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="341" column="17" bodyfile="taskflow/core/runtime.hpp" bodystart="764" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a29472635df52420e3be81ae19976a687" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Runtime::silent_dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, I first, I last)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>tasks parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="380" column="17" bodyfile="taskflow/core/runtime.hpp" bodystart="772" bodyend="779"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::dependent_async</definition>
        <argsstring>(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fuC.get();<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>You can mix the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and <ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">tf::Runtime::silent_dependent_async</ref> when specifying task dependencies. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="427" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="789" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a033e68b47cecca58c59ee550274ceb6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three named asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>You can mix the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and <ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">tf::Runtime::silent_dependent_async</ref> when specifying task dependencies. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="474" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="797" bodyend="802"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a7cd6502c12443a04f39d6ec139adff42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::dependent_async</definition>
        <argsstring>(F &amp;&amp;func, I first, I last)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>You can mix the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and rt::Runtime::silent_dependent_async when specifying task dependencies. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="520" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="808" bodyend="810"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a5386a0f3a4460f8a471d76be2ea36f11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Runtime::dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, I first, I last)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of predecessors finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three named asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">silent_dependent_async</ref>(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>rt.<ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">dependent_async</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});<sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>of<sp/>all<sp/>tasks<sp/>at<sp/>the<sp/>end<sp/>of<sp/>runtime&apos;s<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>You can mix the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" kindref="member">tf::Runtime::dependent_async</ref> and <ref refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" kindref="member">tf::Runtime::silent_dependent_async</ref> when specifying task dependencies. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="570" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="816" bodyend="821"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Runtime::corun</definition>
        <argsstring>()</argsstring>
        <name>corun</name>
        <briefdescription>
<para>corun all tasks spawned by this runtime with other workers </para>
        </briefdescription>
        <detaileddescription>
<para>Coruns all tasks spawned by this runtime cooperatively with other workers in the same executor until all these tasks finish. Under cooperative execution, a worker is not preempted. Instead, it continues participating in the work-stealing loop, executing available tasks alongside other workers. <linebreak/>
</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal">taskflow.emplace([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>spawn<sp/>100<sp/>async<sp/>tasks<sp/>and<sp/>wait</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;100;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">corun</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(counter<sp/>==<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>spawn<sp/>another<sp/>100<sp/>async<sp/>tasks<sp/>and<sp/>wait</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;100;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">corun</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(counter<sp/>==<sp/>200);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>This method can only be called by the parent worker of this runtime, or the behavior is undefined. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="608" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="676" bodyend="684"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1afcc18484a95fd2a834940d878eaf4dfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Runtime::corun_all</definition>
        <argsstring>()</argsstring>
        <name>corun_all</name>
        <briefdescription>
<para>equivalent to <ref refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" kindref="member">tf::Runtime::corun</ref> - just an alias for legacy purpose </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="613" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="687" bodyend="689"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Runtime_1a20d9756a7aa6b58d0d04437818c10066" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::Runtime::is_cancelled</definition>
        <argsstring>()</argsstring>
        <name>is_cancelled</name>
        <briefdescription>
<para>This method verifies if the task has been cancelled. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="618" column="8" bodyfile="taskflow/core/runtime.hpp" bodystart="691" bodyend="693"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classtf_1_1Runtime_1abe76e072e64f5d1b1fe09c7e7c22777e" prot="private" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>tf::Runtime::Runtime</definition>
        <argsstring>(Executor &amp;, Worker &amp;, Node *)</argsstring>
        <name>Runtime</name>
        <param>
          <type><ref refid="classtf_1_1Executor" kindref="compound">Executor</ref> &amp;</type>
          <defname>executor</defname>
        </param>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
          <defname>worker</defname>
        </param>
        <param>
          <type>Node *</type>
          <defname>parent</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/runtime.hpp" line="625" column="12" bodyfile="taskflow/core/runtime.hpp" bodystart="644" bodyend="648"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>class to include a runtime object in a task </para>
    </briefdescription>
    <detaileddescription>
<para>A runtime object provides an interface for interacting with the scheduling system from within a task (i.e., the parent task of this runtime). It enables operations such as spawning asynchronous tasks, executing tasks cooperatively, and implementing recursive parallelism. The runtime guarantees an implicit join at the end of its scope, so all spawned tasks will finish before the parent runtime task continues to its successors.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>(num_threads);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>spawn<sp/>1000<sp/>asynchronous<sp/>tasks<sp/>from<sp/>this<sp/>runtime<sp/>task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;1000;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rt.<ref refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" kindref="member">silent_async</ref>([&amp;](){<sp/>counter.fetch_add(1,<sp/>std::memory_order_relaxed);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>implicit<sp/>synchronization<sp/>at<sp/>the<sp/>end<sp/>of<sp/>the<sp/>runtime<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>REQUIRE(counter.load(std::memory_order_relaxed)<sp/>==<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" kindref="member">executor</ref>.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>A runtime object is associated with the worker and the executor that runs its parent task.</para>
<para><simplesect kind="note"><para>To understand how Taskflow schedules a runtime task, please refer to <ref refid="RuntimeTasking" kindref="compound">Runtime Tasking</ref>. </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="taskflow/core/runtime.hpp" line="49" column="1" bodyfile="taskflow/core/runtime.hpp" bodystart="49" bodyend="641"/>
    <listofallmembers>
      <member refid="classtf_1_1Runtime_1a8074028372bb09946927b1b6ec01c6e1" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>_executor</name></member>
      <member refid="classtf_1_1Runtime_1ac040d7410fbb82703ac39ac3b1baf8fd" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>_parent</name></member>
      <member refid="classtf_1_1Runtime_1ae9bd2bcb1e004b078f627472fb9e0371" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>_worker</name></member>
      <member refid="classtf_1_1Runtime_1ab016b9124e80f55ad92e01579c060f08" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>Algorithm</name></member>
      <member refid="classtf_1_1Runtime_1a5688b13034f179c4a8b2b0ebbb215051" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>async</name></member>
      <member refid="classtf_1_1Runtime_1a333a76d63e50f3ddfbea60c4356b86f3" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>async</name></member>
      <member refid="classtf_1_1Runtime_1aba54a7cacffb54f5eb133730d256a7c4" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>corun</name></member>
      <member refid="classtf_1_1Runtime_1afcc18484a95fd2a834940d878eaf4dfc" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>corun_all</name></member>
      <member refid="classtf_1_1Runtime_1a42e87733508e3610d34728a38e975177" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a033e68b47cecca58c59ee550274ceb6f" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a7cd6502c12443a04f39d6ec139adff42" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a5386a0f3a4460f8a471d76be2ea36f11" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a4ee48a82df1f9758a999d18e6015cec4" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>executor</name></member>
      <member refid="classtf_1_1Runtime_1a763b2f90bc53f92d680a635fe28e858e" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>Executor</name></member>
      <member refid="classtf_1_1Runtime_1a61184f9bd9c801d0a5eccecfdbddc641" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>FlowBuilder</name></member>
      <member refid="classtf_1_1Runtime_1a20d9756a7aa6b58d0d04437818c10066" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>is_cancelled</name></member>
      <member refid="classtf_1_1Runtime_1adb56fdbfd3879bf32dbc9b766e797b55" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>PreemptionGuard</name></member>
      <member refid="classtf_1_1Runtime_1abe76e072e64f5d1b1fe09c7e7c22777e" prot="private" virt="non-virtual"><scope>tf::Runtime</scope><name>Runtime</name></member>
      <member refid="classtf_1_1Runtime_1aa7e72cc0f298475195b252c8f1793343" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>schedule</name></member>
      <member refid="classtf_1_1Runtime_1a0ce29efa2106c8c5a1432e4a55ab2e05" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_async</name></member>
      <member refid="classtf_1_1Runtime_1a532d8cd09ebee59023e3ad65f3220f4e" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_async</name></member>
      <member refid="classtf_1_1Runtime_1a1b89026b619e145c7e2c5c223a0adfc7" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1abc1a77a8896529a8dea6f86997ea10e5" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a3e5e2347c6ec2f29be72aaaf4c75391e" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1a29472635df52420e3be81ae19976a687" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Runtime_1ae1dbce75fd7375ae3bf38948638e34ec" prot="public" virt="non-virtual"><scope>tf::Runtime</scope><name>worker</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
